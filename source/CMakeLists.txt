CMAKE_MINIMUM_REQUIRED ( VERSION 3.12 )
project( drgb VERSION 0.1.0 )

SET ( CMAKE_VERBOSE_MAKEFILE false )

IF ( NOT SYSTEM_SERVICE_NAME )
	SET ( SYSTEM_SERVICE_NAME systemd )
ENDIF()

SET ( CONFIG_FILENAME ${PROJECT_NAME}.conf )
SET ( CONFIG_DIR "/etc/${PROJECT_NAME}" )
SET ( SERVICE_FILENAME ${PROJECT_NAME}-${SYSTEM_SERVICE_NAME}.sh )
SET ( SERVICE_DIR "/etc/init.d" )
SET ( SYSLOGCONF_FILENAME ${PROJECT_NAME}-syslog-ng.conf )
SET ( SYSLOGCONF_DIR /etc/syslog-ng/conf.d/ )
SET ( SSL_FILENAME ${PROJECT_NAME}.key ${PROJECT_NAME}.crt )
SET ( SSL_DIR "/etc/ssl" )

SET ( OUTPUT_DIR ${CMAKE_CURRENT_LIST_DIR}/build )
SET ( INSTALL_DIR /usr/local/${PROJECT_NAME}/ )	#실제 실행파일이 존재하는 디렉토리.
SET ( EXEC_INSTALL_DIR /usr/bin/ )

#Debug모드일 때, __DEBUG__ 매크로 등록
SET ( DEBUG_MACRO "-D__DEBUG__" )
SET ( CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG} ${DEBUG_MACRO}" )
SET ( CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} ${DEBUG_MACRO}" )
#Release모드일 때, config path를 절대경로로 등록.
SET ( RELEASE_MACRO "-D__RELEASE__" )
SET ( CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE} ${RELEASE_MACRO}")
SET ( CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} ${RELEASE_MACRO}")

ADD_COMPILE_OPTIONS ( -std=c++17 )

#별도의 BUILD_TARGET이 설정되면 TEST_TARGET은 사라진다.
IF( NOT BUILD_TARGET )
	SET ( BUILD_TARGET auth match battle )
	SET ( TEST_TARGET test_unit test_stress )
	include(CTest)
	enable_testing()
ELSE()
	SET ( CPACK_PACKAGE_NAME ${PROJECT_NAME} )
	SET ( CPACK_PACKAGE_VENDOR ${PROJECT_NAME} )
	#SET ( CPAKC_PACKAGE_VERSION_MAJOR ${CMAKE_PROJECT_VERSION_MAJOR})	#MAJOR, MINOR, PATCH 모두 별도 설정 없으면 project()의 값을 따름.
	SET ( CPACK_GENERATOR "DEB" )
	SET ( CPACK_DEBIAN_PACKAGE_MAINTAINER "${PROJECT_NAME}")	#Default Value: CPACK_PACKAGE_CONTACT. Default variable을 SET해도 된다.
	SET ( CPACK_PACKAGE_DIRECTORY "${CMAKE_SOURCE_DIR}/package")
	SET ( CPACK_DEBIAN_PACKAGE_DEPENDS "libgrpc++-dev, libpqxx-dev, libprotobuf-dev" )

	#Target 수에 따라 패키지 파일의 꼬리이름을 변경.
	LIST ( LENGTH BUILD_TARGET TARGET_COUNT )
	IF ( auth IN_LIST BUILD_TARGET AND match IN_LIST BUILD_TARGET AND battle IN_LIST BUILD_TARGET )
		SET ( PACKAGE_TAIL_NAME "all" )
	ELSEIF ( ${TARGET_COUNT} EQUAL 1 )
		SET ( PACKAGE_TAIL_NAME "${BUILD_TARGET}")
	ELSE()
		SET ( PACKAGE_TAIL_NAME "custom" )
	ENDIF()
	SET ( CPACK_PACKAGE_NAME "${PROJECT_NAME}-${PACKAGE_TAIL_NAME}")
	###
	
	include(CPack)
ENDIF()

SET ( DIRS
	utils
	security
	threads
	postgres
	redis
	proto
	network
	templates
	
	${BUILD_TARGET}
	${TEST_TARGET}

	manager
)

INCLUDE_DIRECTORIES ( ${DIRS} )
FOREACH ( DIR IN LISTS DIRS )
	ADD_SUBDIRECTORY( ${DIR} )
ENDFOREACH()


#Build Result 저장 경로 설정
SET_TARGET_PROPERTIES ( 
	${BUILD_TARGET} manager
	PROPERTIES
	RUNTIME_OUTPUT_DIRECTORY ${OUTPUT_DIR}
	ARCHIVE_OUTPUT_DIRECTORY ${OUTPUT_DIR}
)

#INSTALL 타겟 경로 설정
INSTALL ( TARGETS ${BUILD_TARGET}
	RUNTIME DESTINATION ${INSTALL_DIR}
	LIBRARY DESTINATION ${INSTALL_DIR}
)
INSTALL ( TARGETS manager
	PERMISSIONS OWNER_READ OWNER_WRITE OWNER_EXECUTE GROUP_READ GROUP_EXECUTE 
	RUNTIME DESTINATION ${EXEC_INSTALL_DIR}
	LIBRARY DESTINATION ${EXEC_INSTALL_DIR}
)

#리소스 별 설치폴더 지정.
INSTALL ( FILES resources/${SYSLOGCONF_FILENAME} DESTINATION ${SYSLOGCONF_DIR} )
INSTALL ( FILES resources/${CONFIG_FILENAME} DESTINATION ${CONFIG_DIR} )
FOREACH ( SSL_FILE IN LISTS SSL_FILENAME )
	IF ( EXISTS "reosurces/${SSL_FILE}" )
		INSTALL ( FILES resources/${SSL_FILE} DESTINATION ${SSL_DIR} )
	ENDIF()
ENDFOREACH()
FOREACH ( TARGET IN LISTS BUILD_TARGET )
	INSTALL ( 
		FILES resources/${SERVICE_FILENAME} 
		RENAME ${PROJECT_NAME}-${TARGET}
		PERMISSIONS OWNER_WRITE OWNER_READ OWNER_EXECUTE GROUP_WRITE GROUP_READ GROUP_EXECUTE WORLD_WRITE WORLD_READ WORLD_EXECUTE
		DESTINATION ${SERVICE_DIR} 
	)
ENDFOREACH()